
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module c16(

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	CPU_RESET_n,
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// LED //////////
output		     [7:0]		LEDG;
output		     [9:0]		LEDR;

//////////// KEY //////////
input 		          		CPU_RESET_n;
input 		     [3:0]		KEY;

//////////// SW //////////
input 		     [9:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;


//=======================================================
//  REG/WIRE declarations
//=======================================================

	reg init = 1;
    reg [15:0]f_pc = 0;
    reg [15:0]pc_next = 0;
    reg [15:0]pc_temp = 0;
    
    reg [15:0]d_pc = 0;
    wire [3:0]d_op;
    wire [3:0]d_r1;
    wire [3:0]d_r2;
    wire [15:0]d_oprand1;
    wire [15:0]d_oprand2;
    wire [15:0]d_reg1;
    wire [15:0]d_reg2;
    wire [15:0]d_reg3;
    wire [2:0]d_dest;
    wire d_wren;
    wire [2:0]d_stall;

    wire[15:0]x_res;
    wire x_wren;
    wire [2:0]x_dest;
    wire [15:0]x_dv;
    wire [16:0]x_jmp;
    wire x_halt;
    wire [1:0]mem_access;

    wire [15:0]m_res; 
    wire m_wren;
    wire [2:0]m_dest;
    wire m_store;
    wire m_load;
    wire [15:0]m_data;
    wire [16:0]m_jmp;
    wire m_halt;

    wire clk = KEY[0];
    reg [3:0]whichreg;
    wire [15:0]rval;
    wire [15:0]f_inst;
    wire [15:0]d_inst;
    wire [15:0]x_inst;
    reg [15:0]stall_inst;

    reg jumped;
    reg store = 0;
    reg load = 0;
    reg [15:0]st_addr = 0;
    reg [15:0]ld_addr = 0;
    reg [15:0]st_data = 0;
    reg [15:0]ld_data = 0;
    reg [2:0]ld_dest = 0;
    reg [2:0]ld_stall = 0;
    reg [2:0]ld_reg = 0;

	assign LEDR = d_pc[9:0];
	assign LEDG = 0;

//=======================================================
//  Structural coding
//=======================================================

	ram prog(
        .address_a(pc_next),       
        .address_b(store ? st_addr : load ? ld_addr : 0),
        .clock(clk),
        .data_a(0),
        .data_b(store ? st_data : 0),
        .rden_a(1),     			
        .rden_b(load),
        .wren_a(0),
        .wren_b(store),
        .q_a(f_inst),
        .q_b(ld_data)
    );

    rf get_rval(
    	.clk(clk), 
    	.a(f_inst[10:8]),
    	.b(f_inst[7:5]), 
    	.c(f_inst[2:0]),
    	.d((ld_data > 0 && d_stall == 1) ? ld_reg : x_dest),
    	.e(whichreg), 
    	.wrval((ld_data > 0 && d_stall == 1) ? ld_data : x_res), 
    	.wren((ld_data > 0 && d_stall == 1) ? 1: (x_dest == 7) ? 0 : x_wren),
    	.ret1(d_reg1),
    	.ret2(d_reg2),
    	.ret3(d_reg3),
    	.display(rval)
    );

	always @(*) begin
		pc_temp = f_pc + 1;

		if (init) begin
			pc_next = 0;
		end
		else begin
			if (m_jmp[16])
				pc_next = f_pc + 1;
			else
				pc_next = m_jmp;
		end
	end

	// display
	always @(*) begin
        if (SW[0])
            whichreg[0] <= 1;
        else
            whichreg[0] <= 0;
        if (SW[1])
            whichreg[1] <= 1;
        else
            whichreg[1] <= 0;
        if (SW[2])
            whichreg[2] <= 1;
        else
            whichreg[2] <= 0;
        if (SW[3])
            whichreg[3] <= 1;
        else
            whichreg[3] <= 0;
    end

    decode d_stage (
    	clk, 
    	(d_stall > 0 || jumped || m_jmp[16] == 0 || m_halt) ? 16'h0000 : f_inst, 
    	f_pc,
    	d_op,
    	d_r1,
    	d_r2,
    	d_oprand1, 
    	d_oprand2, 
    	d_dest, 
    	d_wren,
    	d_stall
    );

    execute x_stage(
    	clk, 
    	(m_jmp[16] == 0 || m_halt) ? 7 : d_dest,
    	d_wren, 
    	d_op, 
    	d_r1,
    	d_r2,
    	d_oprand1, 
    	d_oprand2, 
    	d_reg1,
    	d_reg2,
    	d_reg3,
    	x_res, 
    	x_wren, 
    	x_dest,
    	x_dv,
    	mem_access,
    	x_jmp,
    	x_halt
    );

    memory m_stage(
    	clk, 
    	(m_jmp[16] == 0) ? 0 : mem_access,
    	x_res, 
    	x_wren, 
    	(m_jmp[16] == 0) ? 7 : x_dest, 
    	x_dv,
    	x_jmp,
    	m_halt ? 1 : x_halt,
    	m_res, 
    	m_wren, 
    	m_dest,
    	m_store,
    	m_load,
    	m_data,
    	m_jmp,
    	m_halt
    );

	seg7 d0(SW[9] ? f_pc[3:0] : 
			SW[8] ? pc_next[3:0] :
			SW[7] ? ld_data[3:0] :
			SW[6] ? ld_reg : 
			SW[3] ? f_inst[3:0] : rval[3:0], HEX0);
    seg7 d1(SW[9] ? f_pc[7:4] : 
    		SW[8] ? pc_next[7:4] :
    		SW[7] ? ld_data[7:4] :
    		SW[6] ? d_stall : 
    		SW[3] ? f_inst[7:4] : rval[7:4], HEX1);
    seg7 d2(SW[9] ? f_pc[11:8] : 
    		SW[8] ? pc_next[11:8] :
    		SW[7] ? ld_data[11:8] :
    		SW[6] ? d_reg2 : 
    		SW[3] ? f_inst[11:8] : rval[11:8], HEX2);
    seg7 d3(SW[9] ? f_pc[15:12] : 
    		SW[8] ? pc_next[15:12] :
    		SW[7] ? ld_data[15:12] :
    		SW[6] ? d_reg1 : 
    		SW[3] ? f_inst[15:12] : rval[15:12], HEX3);    

    always @(posedge clk) begin
    	if (init > 0) begin
    		init <= init - 1; 
    		f_pc <= pc_next;
		end 
		else begin
			if (d_stall > 0 || m_halt)
				f_pc <= f_pc;
			else 
				f_pc <= pc_next;

			if (!m_jmp[16])
				jumped <= 1;
			else
				jumped <= 0;

			store <= m_store;
			st_addr <= m_res;
			st_data <= m_data;

			load <= m_load;
			ld_addr <= m_res;
			ld_dest <= m_dest;
			ld_stall <= ld_dest;
			ld_reg <= ld_stall;

	    	if (d_stall > 0) begin
	    		stall_inst <= stall_inst;
	    		d_pc <= f_pc - 1;
	    	end
	    	else begin
	    		stall_inst <= f_inst;
	    		d_pc <= f_pc;
	    	end
    	end
    end
endmodule

module decode(clk, d_inst, d_pc, op, d_r1, d_r2, oprand1, oprand2, d_dest, d_wren, d_stall);
	input clk;
	input [15:0]d_inst;
	input [15:0]d_pc;

	output [3:0]op;
	output [3:0]d_r1;
	output [3:0]d_r2;
	output [15:0]oprand1;
	output [15:0]oprand2;
	output [2:0]d_dest;
	output d_wren;
	output [2:0]d_stall;

	reg [3:0]op;
	reg [3:0]d_r1;
	reg [3:0]d_r2;
	reg [15:0]oprand1;
	reg [15:0]oprand2;
	reg [2:0]d_dest;
	reg d_wren;
	reg [2:0]d_stall;

	reg write;
	reg [15:0]d_va;
	reg [15:0]d_vb;
	reg [3:0]d_ra;
	reg [3:0]d_rb;

	wire f = d_inst[11];

	always @(*) begin
		d_ra = 8;
		d_rb = 8;
		d_va = 0;
		d_vb = 0;
		write = 0;

		case(d_inst[15:12])
			4'b0000 : begin
				if (d_inst == 16'h0000) begin	//noop
				end
				else begin		//add
					write = 1;
					if (f == 0) begin
						d_ra = d_inst[7:5];
						d_vb = d_inst[4:0];
					end
					else begin
						d_ra = d_inst[7:5];
						d_rb = d_inst[2:0];
					end
				end
			end

			4'b0010 : begin 	//slt
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[4:0];
				end
				else begin
					d_ra = d_inst[7:5];
					d_rb = d_inst[2:0];
				end
			end

			4'b1000 : begin 	//shl
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[3:0];
				end
				else begin
					d_ra = d_inst[7:5];
					d_rb = d_inst[2:0];
				end
			end

			4'b1010 : begin		//load
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[4:0];
				end
				else begin
					d_va = d_pc;
					d_vb = d_inst[7:0];
				end
			end

			4'b1011 : begin 	//store
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[4:0];
				end
				else begin
					d_va = d_pc;
					d_vb = d_inst[7:0];
				end
			end

			4'b1100 : begin 	//lea
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[3:0];
				end
				else begin
					d_va = d_pc;
					d_vb = d_inst[7:0];
				end
			end

			4'b1101 : begin		//call
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_va = d_pc;
					d_vb = d_inst[4:0];
				end
				else begin
					d_va = d_pc;
					d_vb = d_inst[7:0];
				end
			end

			4'b1111 : begin	
				if (d_inst == 16'hffff) begin	//halt
					d_va = d_pc - 1;
				end
				else begin						//brz
					if (f == 0) begin
						d_ra = d_inst[7:5];
						d_vb = d_inst[4:0];
					end
					else begin
						d_va = d_pc;
						d_vb = d_inst[7:0];
					end
				end
			end

			default : begin
			end
		endcase
	end

	always @(posedge clk) begin 
		op <= d_inst[15:12];
		d_r1 <= d_ra;
		d_r2 <= d_rb;
		oprand1 <= d_va;
		oprand2 <= d_vb;
		d_wren <= write;
		d_dest <= d_inst[10:8];

		if (d_stall > 0)
			d_stall <= d_stall - 1;
		else begin
			if (d_inst[15:12] == 4'b1010)
				d_stall <= 6;
			else
				d_stall <= 0;
		end
    end
endmodule

module execute(clk, d_dest, d_wren, d_op, d_r1, d_r2, d_oprand1, d_oprand2, d_reg1, d_reg2, d_reg3, x_res, x_wren, x_dest, x_dv, mem_access, x_jmp, x_halt);
	input clk;
	input [2:0]d_dest;
	input d_wren;
	input [3:0]d_op;
	input [3:0]d_r1;
	input [3:0]d_r2;
	input [15:0]d_oprand1;
	input [15:0]d_oprand2;
	input [15:0]d_reg1;
	input [15:0]d_reg2;
	input [15:0]d_reg3;

	output [15:0]x_res;
	output x_wren;
	output [2:0]x_dest;
	output [15:0]x_dv;
	output [1:0]mem_access;
	output [16:0]x_jmp;
	output x_halt;

	reg [15:0]temp;
	reg [15:0]x_res;
	reg x_wren;
	reg [2:0]x_dest;
	reg [15:0]x_dv;
	reg [2:0]dest;
	reg [16:0]x_jmp;
	reg x_halt;

	reg [2:0]temp_reg;
	reg [15:0]temp_val;
	reg [1:0]mem_access;
	reg [16:0]jmp;
	reg [1:0]mem;
	reg [15:0]vd;
	reg [15:0]va;
	reg [15:0]vb;
	reg halt;

	always @(*) begin
		temp = 0;
		dest = 7;
		jmp = 17'b10000000000000000;
		mem = 0;
		vd = d_reg1;
		va = (d_r1 == temp_reg) ? temp_val : (d_r1 < 8) ? d_reg2 : d_oprand1;
		vb = (d_r2 == temp_reg) ? temp_val : (d_r2 < 8) ? d_reg3 : d_oprand2;
		halt = 0;

		case(d_op)
			4'b0000 : begin 	//add
				dest = d_dest;
				temp = va + vb;
			end

			4'b0010 : begin 	//slt
				dest = d_dest;
				temp = va < vb;
			end

			4'b1000 : begin 	//shl
				dest = d_dest;
				temp = va << vb;
			end

			4'b1010 : begin		//load
				dest = d_dest;
				mem = 1;
				temp = va + vb;
			end

			4'b1011 : begin 	//store
				mem = 2;
				temp = va + vb;
			end

			4'b1100 : begin 	//lea
				dest = d_dest;
				temp = va + vb;
			end

			4'b1101 : begin		//call
				dest = d_dest;
				if (d_r1 < 8) begin
					temp = d_oprand1;
					jmp = va + d_oprand2;
				end
				else begin
					temp = d_oprand1;
					jmp = d_oprand1 + d_oprand2;
				end
			end

			4'b1111 : begin		//halt
				if (d_r1 == 8 && d_oprand2 == 0) begin
					jmp = va;
					halt = 1;
				end
				else begin		//brz
					jmp = (vd == 0) ? (va + vb) : 17'b10000000000000000;
				end
			end

			default : begin
				dest = 7;
			end
		endcase
	end

	always @(posedge clk) begin  
		x_res <= temp;
		x_wren <= d_wren;
		x_jmp <= jmp;
		x_dv <= vd;
		mem_access <= mem;
		x_dest <= dest;
		x_halt <= halt;

		if (dest != 7 && d_wren) begin
			temp_reg = dest;
			temp_val = temp;
		end
		else begin
			temp_reg = 3'b111;
			temp_val = 0;
		end
    end
endmodule

module memory(clk, mem_access, x_res, x_wren, x_dest, x_dv, x_jmp, x_halt, m_res, m_wren, m_dest, m_store, m_load, m_data, m_jmp, m_halt);
	input clk;
	input [1:0]mem_access;
	input [15:0]x_res;
	input x_wren;
	input [2:0]x_dest;
	input [15:0]x_dv;
	input [16:0]x_jmp;
	input x_halt;

	output [15:0]m_res;
	output m_wren;
	output [2:0]m_dest;
	output m_store;
	output m_load;
	output [15:0]m_data;
	output [16:0]m_jmp;
	output m_halt;

	reg [15:0]m_res;
	reg m_wren;
	reg [2:0]m_dest;
	reg m_store;
	reg m_load;
	reg [15:0]m_data;
	reg [16:0]m_jmp;
	reg m_halt;

	reg [15:0]data;
	reg [1:0]cnt = 2;
	reg halt;

	always @(*) begin
		data = 0;
		halt = 0;
		if (mem_access > 0) begin
			if (mem_access == 1) begin	//ld
			end
			else begin					//st
				data = x_dv;
			end
		end

		if (x_halt) begin
			halt = 1;
		end
	end

	always @(posedge clk) begin  
		m_res <= x_res;
		m_wren <= x_wren;
		m_dest <= x_dest;
		m_data <= data;
		m_halt <= halt;

		if (cnt > 0) begin
			cnt <= cnt - 1;
			m_jmp <= 17'b10000000000000000;
			m_halt <= 0;
		end
		else begin
			m_jmp <= x_jmp;
			m_halt <= halt;
		end

		if (mem_access == 2) 
			m_store <= 1;
		else begin
			if (mem_access == 1)
				m_load <= 1;
			else begin
				m_load <= 0;
				m_store <= 0;
			end
		end
    end
endmodule

module rf(clk, a, b, c, d, e, wrval, wren, ret1, ret2, ret3, display);
	input clk;
	input [2:0]a;
	input [2:0]b;
	input [2:0]c;
	input [2:0]d;
	input [2:0]e;
	input [15:0]wrval;
	input wren;

	output [15:0]ret1;
	output [15:0]ret2;
	output [15:0]ret3;
	output [15:0]display;

	reg [15:0]regs[7:0];

	reg [15:0]ret1;
	reg [15:0]ret2;
	reg [15:0]ret3;

	wire [15:0]display = regs[e];

	always @(posedge clk) begin
		if (wren) 
			regs[d] <= wrval;

		if (a == d && wren)
			ret1 <= wrval;
		else
			ret1 <= regs[a];

		if (b == d && wren)
			ret2 <= wrval;
		else
			ret2 <= regs[b];

		if (c == d && wren)
			ret3 <= wrval;
		else	
			ret3 <= regs[c];
	end
endmodule

module seg7(in,out);
    input [3:0]in;
    output [6:0]out;
    reg [6:0] out;

    always @(*) begin
        case (in)           // 6543210
            4'b0000 : out = 7'b1000000;
            4'b0001 : out = 7'b1111001;
            4'b0010 : out = 7'b0100100;
            4'b0011 : out = 7'b0110000;
            4'b0100 : out = 7'b0011001;
            4'b0101 : out = 7'b0010010;
            4'b0110 : out = 7'b0000010;
            4'b0111 : out = 7'b1111000;
            4'b1000 : out = 7'b0000000;
            4'b1001 : out = 7'b0011000;
            4'b1010 : out = 7'b0001000;
            4'b1011 : out = 7'b0000011;
            4'b1100 : out = 7'b0100111;
            4'b1101 : out = 7'b0100001;
            4'b1110 : out = 7'b0000110;
            4'b1111 : out = 7'b0001110;
            default:  out = 7'b1111111; 
        endcase
    end
endmodule