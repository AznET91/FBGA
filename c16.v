
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module c16(

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	CPU_RESET_n,
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// LED //////////
output		     [7:0]		LEDG;
output		     [9:0]		LEDR;

//////////// KEY //////////
input 		          		CPU_RESET_n;
input 		     [3:0]		KEY;

//////////// SW //////////
input 		     [9:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;


//=======================================================
//  REG/WIRE declarations
//=======================================================

	reg init = 1;
    reg [15:0]f_pc = 0;
    reg [15:0]pc_next = 0;
    
    reg [15:0]d_pc = 0;
    wire [3:0]op;
    wire [3:0]d_r1;
    wire [3:0]d_r2;
    wire [15:0]d_oprand1;
    wire [15:0]d_oprand2;
    wire [15:0]d_reg1;
    wire [15:0]d_reg2;
    wire [2:0]d_dest;
    wire d_wren;

    reg [15:0]x_pc = 0;
    wire[15:0]x_res;
    wire x_wren;
    wire [2:0]x_dest;
    wire [1:0]mem_access;

    wire [15:0]m_res; 
    wire m_wren;
    wire [2:0]m_dest;
    wire m_store;

    wire clk = KEY[0];
    reg [3:0]whichreg;
    wire [15:0]rval;
    wire [15:0]f_inst;
    wire [15:0]d_inst;
    wire [15:0]x_inst;
    wire [16:0]jmp;

	assign LEDR = d_pc[9:0];
	assign LEDG = 0;

//=======================================================
//  Structural coding
//=======================================================

	ram prog(
        .address(pc_next),          // address is registered
        .clock(clk),
        .data(0),
        .rden(1),     				// RDEN is also registered
        .wren(m_store),
        .q(f_inst));

	always @(*) begin
		if (init) begin
			pc_next = 0;
		end
		else begin
			if (jmp[16] == 1)
				pc_next = f_pc + 1;
			else
				pc_next = jmp - 1;
		end
	end

	// display
	always @(*) begin
        if (SW[0])
            whichreg[0] <= 1;
        else
            whichreg[0] <= 0;
        if (SW[1])
            whichreg[1] <= 1;
        else
            whichreg[1] <= 0;
        if (SW[2])
            whichreg[2] <= 1;
        else
            whichreg[2] <= 0;
        if (SW[3])
            whichreg[3] <= 1;
        else
            whichreg[3] <= 0;
    end

    decode d_stage (
    	clk, 
    	(jmp[16] == 0) ? 16'h0000 : f_inst, 
    	f_pc,
    	op,
    	d_r1,
    	d_r2,
    	d_oprand1, 
    	d_oprand2, 
    	d_dest, 
    	d_wren
    );

    execute x_stage(
    	clk, 
    	(jmp[16] == 0) ? 7 : d_dest,
    	d_wren, 
    	op, 
    	d_r1,
    	d_r2,
    	d_oprand1, 
    	d_oprand2, 
    	x_res, 
    	x_wren, 
    	x_dest,
    	mem_access,
    	jmp
    );

    memory m_stage(
    	clk, 
    	mem_access,
    	x_res, 
    	x_wren, 
    	x_dest, 
    	m_res, 
    	m_wren, 
    	m_dest
    );

    rf get_rval(
    	.clk(clk), 
    	.a(f_inst[7:5]), 
    	.b(f_inst[2:0]),
    	.c(m_dest),
    	.d(whichreg), 
    	.wrval(m_res), 
    	.wren((m_dest == 7) ? 0 : m_wren),
    	.ret1(d_reg1),
    	.ret2(d_reg2),
    	.display(rval)
    );

	seg7 d0(SW[9] ? d_oprand2 : 
			SW[8] ? res :
			SW[3] ? f_inst[3:0] : rval[3:0], HEX0);
    seg7 d1(SW[9] ? d_r2 : 
    		SW[8] ? mem_access :
    		SW[3] ? f_inst[7:4] : rval[7:4], HEX1);
    seg7 d2(SW[9] ? d_r1 : 
    		SW[8] ? x_wren :
    		SW[3] ? f_inst[11:8] : rval[11:8], HEX2);
    seg7 d3(SW[9] ? d_dest : 
    		SW[8] ? x_dest :
    		SW[3] ? f_inst[15:12] : rval[15:12], HEX3);    

     always @(posedge clk) begin
    	if (init > 0) begin
    		init <= init - 1; 
    		f_pc <= pc_next;
		end 
		else begin
			f_pc <= pc_next;	
	    	d_pc <= f_pc;
	    	x_pc <= d_pc;
    	end
    end
endmodule

module decode(clk, d_inst, d_pc, op, d_r1, d_r2, oprand1, oprand2, d_dest, d_wren);
	input clk;
	input [15:0]d_inst;
	input [15:0]d_pc;

	output [3:0]op;
	output [3:0]d_r1;
	output [3:0]d_r2;
	output [15:0]oprand1;
	output [15:0]oprand2;
	output [2:0]d_dest;
	output d_wren;

	reg [15:0]d_va;
	reg [15:0]d_vb;
	reg [3:0]d_ra;
	reg [3:0]d_rb;

	reg [3:0]d_r1;
	reg [3:0]d_r2;
	reg [15:0]oprand1;
	reg [15:0]oprand2;
	reg [2:0]d_dest;
	reg d_wren;
	reg write;
	reg [3:0]op;

	wire f = d_inst[11];

	always @(*) begin
		d_ra = 8;
		d_rb = 8;
		d_va = 0;
		d_vb = 0;
		write = 0;

		case(d_inst[15:12])
			4'b0000 : begin
				if (d_inst == 16'h0000) begin	//noop
				end
				else begin		//add
					write = 1;
					if (f == 0) begin
						d_ra = d_inst[7:5];
						d_vb = d_inst[4:0];
					end
					else begin
						d_ra = d_inst[7:5];
						d_rb = d_inst[2:0];
					end
				end
			end

			4'b0010 : begin 	//slt
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[4:0];
				end
				else begin
					d_ra = d_inst[7:5];
					d_rb = d_inst[2:0];
				end
			end

			4'b1000 : begin 	//shl
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[3:0];
				end
				else begin
					d_ra = d_inst[7:5];
					d_rb = d_inst[2:0];
				end
			end

			4'b1010 : begin		//load
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[4:0];
				end
				else begin
					d_va = d_pc;
					d_vb = d_inst[7:0];
				end
			end

			4'b1011 : begin 	//store
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[4:0];
				end
				else begin
					d_va = d_pc;
					d_vb = d_inst[7:0];
				end
			end

			4'b1100 : begin 	//lea
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[3:0];
				end
				else begin
					d_va = d_pc;
					d_vb = d_inst[7:0];
				end
			end

			4'b1101 : begin		//call
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_va = d_pc;
					d_vb = d_inst[4:0];
				end
				else begin
					d_va = d_pc;
					d_vb = d_inst[7:0];
				end
			end

			4'b1111 : begin	
				if (d_inst == 16'hffff) begin	//halt
					d_va = d_pc;
				end
				else begin						//brz
					if (f == 0) begin
						d_ra = d_inst[7:5];
						d_vb = d_inst[4:0];
					end
					else begin
						d_va = d_pc;
						d_vb = d_inst[7:0];
					end
				end
			end
		endcase
	end

	always @(posedge clk) begin 
		op <= d_inst[15:12];
		d_r1 <= d_ra;
		d_r2 <= d_rb;
		oprand1 <= d_va;
		oprand2 <= d_vb;
		d_wren <= write;

		d_dest <= d_inst[10:8];
    end
endmodule

module execute(clk, d_dest, d_wren, x_op, x_r1, x_r2, x_oprand1, x_oprand2, res, wren, x_dest, mem_access, jmp);
	input clk;
	input [2:0]d_dest;
	input d_wren;
	input [3:0]x_op;
	input [3:0]x_r1;
	input [3:0]x_r2;
	input [15:0]x_oprand1;
	input [15:0]x_oprand2;

	output [15:0]res;
	output wren;
	output [2:0]x_dest;
	output [1:0]mem_access;
	output [16:0]jmp;

	reg [15:0]temp;
	reg [15:0]res;
	reg wren;
	reg [2:0]x_dest;
	reg [2:0]dest;
	reg [16:0]jmp;

	reg [15:0]regs[7:0];
	reg [1:0]mem_access;
	reg [16:0]x_jmp;
	reg [1:0]mem;

	always @(*) begin
		temp = 0;
		dest = 7;
		x_jmp = 17'b10000000000000000;
		mem = 0;
		case(x_op)
			4'b0000 : begin 	//add
				dest = d_dest;
				if (x_r2 < 8)
					temp = regs[x_r1] + regs[x_r2];
				else
					temp = regs[x_r1] + x_oprand2;
			end

			4'b0010 : begin 	//slt
				dest = d_dest;
				if (x_r2 < 8)
					temp = regs[x_r1] < regs[x_r2];
				else
					temp = regs[x_r1] < x_oprand2;
			end

			4'b1000 : begin 	//shl
				dest = d_dest;
				if (x_r2 < 8)
					temp = regs[x_r1] << regs[x_r2];
				else
					temp = regs[x_r1] << x_oprand2;
			end

			4'b1010 : begin		//load
				mem = 1;
				if (x_r1 < 8)
					temp = regs[x_r1] + x_oprand2;
				else
					temp = x_oprand1 + x_oprand2;
			end

			4'b1011 : begin 	//store
				mem = 2;
				if (x_r1 < 8)
					temp = regs[x_r1] + x_oprand2;
				else
					temp = x_oprand1 + x_oprand2;
			end

			4'b1100 : begin 	//lea
				dest = d_dest;
				if (x_r1 < 8)
					temp = regs[x_r1] + x_oprand2;
				else
					temp = x_oprand1 + x_oprand2;
			end

			4'b1101 : begin		//call
				dest = d_dest;
				if (x_r1 < 8) begin
					temp = x_oprand1;
					x_jmp = regs[x_r1] + x_oprand2;
				end
				else begin
					temp = x_oprand1;
					x_jmp = x_oprand1 + x_oprand2;
				end
			end

			4'b1111 : begin		//halt
				if (x_r1 == 8 && x_oprand2 == 0) begin
					x_jmp = x_oprand1;
				end
				else begin		//brz
					if (x_r1 < 8) 
						x_jmp = (regs[d_dest] == 0) ? (regs[x_r1] + x_oprand2) : 17'b10000000000000000;
					else
						x_jmp = (regs[d_dest] == 0) ? (x_oprand1 + x_oprand2) : 17'b10000000000000000;
				end
			end
		endcase
	end

	always @(posedge clk) begin  
		res <= temp;
		wren <= d_wren;
		x_dest <= dest;
		jmp <= x_jmp;

		if (dest != 7 && d_wren)
			regs[dest] <= temp;

		mem_access <= mem;
    end
endmodule

module memory(clk, mem_access, x_res, x_wren, x_dest, m_res, m_wren, m_dest, m_store);
	input clk;
	input mem_access;
	input [15:0]x_res;
	input x_wren;
	input [2:0]x_dest;

	output [15:0]m_res;
	output m_wren;
	output [2:0]m_dest;
	output m_store;

	reg [15:0]m_res;
	reg m_wren;
	reg [2:0]m_dest;
	reg m_store;

	reg [15:0]m_ld;
	reg [15:0]m_st;

	always @(*) begin
		if (mem_access > 0) begin
			if (mem_access == 1) begin	//ld
				m_ld = x_res;
			end
			else begin					//st
				m_st = x_res;
			end
		end
	end

	always @(posedge clk) begin  
		m_res <= x_res;
		m_wren <= x_wren;
		m_dest <= x_dest;
    end
endmodule

module rf(clk, a, b, c, d, wrval, wren, ret1, ret2, display);
	input clk;
	input [2:0]a;
	input [2:0]b;
	input [2:0]c;
	input [2:0]d;
	input [15:0]wrval;
	input wren;

	output [15:0]ret1;
	output [15:0]ret2;
	output [15:0]display;

	reg [15:0]regs[7:0];

	reg [15:0]ret1;
	reg [15:0]ret2;

	wire [15:0]display = regs[d];

	always @(posedge clk) begin
		if (wren) 
			regs[c] <= wrval;

		ret1 <= regs[a];
		ret2 <= regs[b];
	end
endmodule

module seg7(in,out);
    input [3:0]in;
    output [6:0]out;
    reg [6:0] out;

    always @(*) begin
        case (in)           // 6543210
            4'b0000 : out = 7'b1000000;
            4'b0001 : out = 7'b1111001;
            4'b0010 : out = 7'b0100100;
            4'b0011 : out = 7'b0110000;
            4'b0100 : out = 7'b0011001;
            4'b0101 : out = 7'b0010010;
            4'b0110 : out = 7'b0000010;
            4'b0111 : out = 7'b1111000;
            4'b1000 : out = 7'b0000000;
            4'b1001 : out = 7'b0011000;
            4'b1010 : out = 7'b0001000;
            4'b1011 : out = 7'b0000011;
            4'b1100 : out = 7'b0100111;
            4'b1101 : out = 7'b0100001;
            4'b1110 : out = 7'b0000110;
            4'b1111 : out = 7'b0001110;
            default:  out = 7'b1111111; 
        endcase
    end
endmodule