
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module c16(

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	CPU_RESET_n,
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// LED //////////
output		     [7:0]		LEDG;
output		     [9:0]		LEDR;

//////////// KEY //////////
input 		          		CPU_RESET_n;
input 		     [3:0]		KEY;

//////////// SW //////////
input 		     [9:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;


//=======================================================
//  REG/WIRE declarations
//=======================================================

	reg init = 1;
    reg [15:0]f_pc = 0;
    reg [15:0]pc_next = 0;
    reg [15:0]pc_temp = 0;
    
    reg [15:0]d_pc = 0;
    wire [3:0]op;
    wire [3:0]d_r1;
    wire [3:0]d_r2;
    wire [15:0]d_oprand1;
    wire [15:0]d_oprand2;
    wire [15:0]d_reg1;
    wire [15:0]d_reg2;
    wire [2:0]d_dest;
    wire d_wren;

    reg [15:0]x_pc = 0;
    wire[15:0]x_res;
    wire x_wren;
    wire [2:0]x_dest;
    wire [15:0]x_dv;
    wire [16:0]x_jmp;
    wire x_halt;
    wire [1:0]mem_access;

    wire [15:0]m_res; 
    wire m_wren;
    wire [2:0]m_dest;
    wire m_store;
    wire m_load;
    wire [15:0]m_data;
    wire [16:0]m_jmp;
    wire m_halt;

    wire clk = KEY[0];
    reg [3:0]whichreg;
    wire [15:0]rval;
    wire [15:0]f_inst;
    wire [15:0]d_inst;
    wire [15:0]x_inst;

    reg store = 0;
    reg [15:0]store_mem = 0;
    reg load = 0;
    reg [15:0]data = 0;

	assign LEDR = d_pc[9:0];
	assign LEDG = 0;

//=======================================================
//  Structural coding
//=======================================================

	ram prog(
        .address(pc_next),          // address is registered
        .clock(clk),
        .data(store ? data : 0),
        .rden(1),     				// RDEN is also registered
        .wren(store),
        .q(f_inst));

	always @(*) begin
		pc_temp = f_pc + 1;

		if (init) begin
			pc_next = 0;
		end
		else begin
			if (store || m_load) begin
					pc_next = store_mem;
			end
			else begin
				if (m_jmp[16])
					pc_next = f_pc + 1;
				else
					pc_next = m_jmp;
			end
		end
	end

	// display
	always @(*) begin
        if (SW[0])
            whichreg[0] <= 1;
        else
            whichreg[0] <= 0;
        if (SW[1])
            whichreg[1] <= 1;
        else
            whichreg[1] <= 0;
        if (SW[2])
            whichreg[2] <= 1;
        else
            whichreg[2] <= 0;
        if (SW[3])
            whichreg[3] <= 1;
        else
            whichreg[3] <= 0;
    end

    decode d_stage (
    	clk, 
    	(m_jmp[16] == 0 || m_halt) ? 16'h0000 : f_inst, 
    	f_pc,
    	op,
    	d_r1,
    	d_r2,
    	d_oprand1, 
    	d_oprand2, 
    	d_dest, 
    	d_wren
    );

    execute x_stage(
    	clk, 
    	(m_jmp[16] == 0 || m_halt) ? 7 : d_dest,
    	d_wren, 
    	op, 
    	d_r1,
    	d_r2,
    	d_oprand1, 
    	d_oprand2, 
    	x_res, 
    	x_wren, 
    	x_dest,
    	x_dv,
    	mem_access,
    	x_jmp,
    	x_halt
    );

    memory m_stage(
    	clk, 
    	(m_jmp[16] == 0) ? 0 : mem_access,
    	x_res, 
    	x_wren, 
    	(m_jmp[16] == 0) ? 7 : x_dest, 
    	x_dv,
    	x_jmp,
    	m_halt ? 1 : x_halt,
    	m_res, 
    	m_wren, 
    	m_dest,
    	m_store,
    	m_load,
    	m_data,
    	m_jmp,
    	m_halt
    );

    rf get_rval(
    	.clk(clk), 
    	.a(f_inst[7:5]), 
    	.b(f_inst[2:0]),
    	.c(m_dest),
    	.d(whichreg), 
    	.wrval(m_load ? f_inst : m_res), 
    	.wren(m_load ? 1 : (m_dest == 7) ? 0 : m_wren),
    	.ret1(d_reg1),
    	.ret2(d_reg2),
    	.display(rval)
    );

	seg7 d0(SW[9] ? f_pc[3:0] : 
			SW[8] ? pc_next[3:0] :
			SW[7] ? store_mem[3:0] :
			SW[3] ? f_inst[3:0] : rval[3:0], HEX0);
    seg7 d1(SW[9] ? f_pc[7:4] : 
    		SW[8] ? pc_next[7:4] :
    		SW[7] ? store_mem[7:4] :
    		SW[3] ? f_inst[7:4] : rval[7:4], HEX1);
    seg7 d2(SW[9] ? f_pc[11:8] : 
    		SW[8] ? pc_next[11:8] :
    		SW[7] ? data :
    		SW[3] ? f_inst[11:8] : rval[11:8], HEX2);
    seg7 d3(SW[9] ? f_pc[15:12] : 
    		SW[8] ? pc_next[15:12] :
    		SW[7] ? store :
    		SW[3] ? f_inst[15:12] : rval[15:12], HEX3);    

     always @(posedge clk) begin
    	if (init > 0) begin
    		init <= init - 1; 
    		f_pc <= pc_next;
		end 
		else begin
			if (m_store || m_load)
				f_pc <= pc_temp;
			else begin 
				if (m_halt)
					f_pc <= f_pc;
				else
					f_pc <= pc_next;
			end

			store <= m_store;
			store_mem <= m_res;
			data <= m_data;

	    	d_pc <= f_pc;
	    	x_pc <= d_pc;
    	end
    end
endmodule

module decode(clk, d_inst, d_pc, op, d_r1, d_r2, oprand1, oprand2, d_dest, d_wren);
	input clk;
	input [15:0]d_inst;
	input [15:0]d_pc;

	output [3:0]op;
	output [3:0]d_r1;
	output [3:0]d_r2;
	output [15:0]oprand1;
	output [15:0]oprand2;
	output [2:0]d_dest;
	output d_wren;

	reg [15:0]d_va;
	reg [15:0]d_vb;
	reg [3:0]d_ra;
	reg [3:0]d_rb;

	reg [3:0]d_r1;
	reg [3:0]d_r2;
	reg [15:0]oprand1;
	reg [15:0]oprand2;
	reg [2:0]d_dest;
	reg d_wren;
	reg write;
	reg [3:0]op;

	wire f = d_inst[11];

	always @(*) begin
		d_ra = 8;
		d_rb = 8;
		d_va = 0;
		d_vb = 0;
		write = 0;

		case(d_inst[15:12])
			4'b0000 : begin
				if (d_inst == 16'h0000) begin	//noop
				end
				else begin		//add
					write = 1;
					if (f == 0) begin
						d_ra = d_inst[7:5];
						d_vb = d_inst[4:0];
					end
					else begin
						d_ra = d_inst[7:5];
						d_rb = d_inst[2:0];
					end
				end
			end

			4'b0010 : begin 	//slt
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[4:0];
				end
				else begin
					d_ra = d_inst[7:5];
					d_rb = d_inst[2:0];
				end
			end

			4'b1000 : begin 	//shl
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[3:0];
				end
				else begin
					d_ra = d_inst[7:5];
					d_rb = d_inst[2:0];
				end
			end

			4'b1010 : begin		//load
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[4:0];
				end
				else begin
					d_va = d_pc;
					d_vb = d_inst[7:0];
				end
			end

			4'b1011 : begin 	//store
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[4:0];
				end
				else begin
					d_va = d_pc;
					d_vb = d_inst[7:0];
				end
			end

			4'b1100 : begin 	//lea
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_vb = d_inst[3:0];
				end
				else begin
					d_va = d_pc;
					d_vb = d_inst[7:0];
				end
			end

			4'b1101 : begin		//call
				write = 1;
				if (f == 0) begin
					d_ra = d_inst[7:5];
					d_va = d_pc;
					d_vb = d_inst[4:0];
				end
				else begin
					d_va = d_pc;
					d_vb = d_inst[7:0];
				end
			end

			4'b1111 : begin	
				if (d_inst == 16'hffff) begin	//halt
					d_va = d_pc - 1;
				end
				else begin						//brz
					if (f == 0) begin
						d_ra = d_inst[7:5];
						d_vb = d_inst[4:0];
					end
					else begin
						d_va = d_pc;
						d_vb = d_inst[7:0];
					end
				end
			end
		endcase
	end

	always @(posedge clk) begin 
		op <= d_inst[15:12];
		d_r1 <= d_ra;
		d_r2 <= d_rb;
		oprand1 <= d_va;
		oprand2 <= d_vb;
		d_wren <= write;

		d_dest <= d_inst[10:8];
    end
endmodule

module execute(clk, d_dest, d_wren, x_op, x_r1, x_r2, x_oprand1, x_oprand2, res, wren, x_dest, x_dv, mem_access, x_jmp, x_halt);
	input clk;
	input [2:0]d_dest;
	input d_wren;
	input [3:0]x_op;
	input [3:0]x_r1;
	input [3:0]x_r2;
	input [15:0]x_oprand1;
	input [15:0]x_oprand2;

	output [15:0]res;
	output wren;
	output [2:0]x_dest;
	output [15:0]x_dv;
	output [1:0]mem_access;
	output [16:0]x_jmp;
	output x_halt;

	reg [15:0]temp;
	reg [15:0]res;
	reg wren;
	reg [2:0]x_dest;
	reg [15:0]x_dv;
	reg [2:0]dest;
	reg [16:0]x_jmp;
	reg x_halt;

	reg [15:0]regs[7:0];
	reg [1:0]mem_access;
	reg [16:0]jmp;
	reg [1:0]mem;
	reg [15:0]dv;
	reg halt;

	always @(*) begin
		temp = 0;
		dest = 7;
		jmp = 17'b10000000000000000;
		mem = 0;
		dv = 0;
		halt = 0;
		case(x_op)
			4'b0000 : begin 	//add
				dest = d_dest;
				if (x_r2 < 8)
					temp = regs[x_r1] + regs[x_r2];
				else
					temp = regs[x_r1] + x_oprand2;
			end

			4'b0010 : begin 	//slt
				dest = d_dest;
				if (x_r2 < 8)
					temp = regs[x_r1] < regs[x_r2];
				else
					temp = regs[x_r1] < x_oprand2;
			end

			4'b1000 : begin 	//shl
				dest = d_dest;
				if (x_r2 < 8)
					temp = regs[x_r1] << regs[x_r2];
				else
					temp = regs[x_r1] << x_oprand2;
			end

			4'b1010 : begin		//load
				dest = d_dest;
				mem = 1;
				if (x_r1 < 8)
					temp = regs[x_r1] + x_oprand2;
				else
					temp = x_oprand1 + x_oprand2;
			end

			4'b1011 : begin 	//store
				mem = 2;
				dv = regs[d_dest];
				if (x_r1 < 8)
					temp = regs[x_r1] + x_oprand2;
				else
					temp = x_oprand1 + x_oprand2;
			end

			4'b1100 : begin 	//lea
				dest = d_dest;
				if (x_r1 < 8)
					temp = regs[x_r1] + x_oprand2;
				else
					temp = x_oprand1 + x_oprand2;
			end

			4'b1101 : begin		//call
				dest = d_dest;
				if (x_r1 < 8) begin
					temp = x_oprand1;
					jmp = regs[x_r1] + x_oprand2;
				end
				else begin
					temp = x_oprand1;
					jmp = x_oprand1 + x_oprand2;
				end
			end

			4'b1111 : begin		//halt
				if (x_r1 == 8 && x_oprand2 == 0) begin
					jmp = x_oprand1;
					halt = 1;
				end
				else begin		//brz
					if (x_r1 < 8) 
						jmp = (regs[d_dest] == 0) ? (regs[x_r1] + x_oprand2) : 17'b10000000000000000;
					else
						jmp = (regs[d_dest] == 0) ? (x_oprand1 + x_oprand2) : 17'b10000000000000000;
				end
			end
		endcase
	end

	always @(posedge clk) begin  
		res <= temp;
		wren <= d_wren;
		x_jmp <= jmp;
		x_dv <= dv;
		mem_access <= mem;
		x_dest <= dest;
		x_halt <= halt;

		if (dest != 7 && d_wren)
			regs[dest] <= temp;
    end
endmodule

module memory(clk, mem_access, x_res, x_wren, x_dest, x_dv, x_jmp, x_halt, m_res, m_wren, m_dest, m_store, m_load, m_data, m_jmp, m_halt);
	input clk;
	input [1:0]mem_access;
	input [15:0]x_res;
	input x_wren;
	input [2:0]x_dest;
	input [15:0]x_dv;
	input [16:0]x_jmp;
	input x_halt;

	output [15:0]m_res;
	output m_wren;
	output [2:0]m_dest;
	output m_store;
	output m_load;
	output [15:0]m_data;
	output [16:0]m_jmp;
	output m_halt;

	reg [15:0]m_res;
	reg m_wren;
	reg [2:0]m_dest;
	reg m_store;
	reg m_load;
	reg [15:0]m_data;
	reg [16:0]m_jmp;
	reg m_halt;

	reg [15:0]m_ld;
	reg [15:0]m_st;
	reg [15:0]data;
	reg [1:0]cnt = 2;
	reg halt;

	always @(*) begin
		data = 0;
		halt = 0;
		if (mem_access > 0) begin
			if (mem_access == 1) begin	//ld
				m_ld = x_res;
			end
			else begin					//st
				m_st = x_res;
				data = x_dv;
			end
		end

		if (x_halt) begin
			halt = 1;
		end
	end

	always @(posedge clk) begin  
		m_res <= x_res;
		m_wren <= x_wren;
		m_dest <= x_dest;
		m_data <= data;
		m_halt <= halt;

		if (cnt > 0) begin
			cnt <= cnt - 1;
			m_jmp <= 17'b10000000000000000;
			m_halt <= 0;
		end
		else begin
			m_jmp <= x_jmp;
			m_halt <= halt;
		end

		if (mem_access == 2) 
			m_store <= 1;
		else begin
			if (mem_access == 1)
				m_load <= 1;
			else begin
				m_load <= 0;
				m_store <= 0;
			end
		end
    end
endmodule

module rf(clk, a, b, c, d, wrval, wren, ret1, ret2, display);
	input clk;
	input [2:0]a;
	input [2:0]b;
	input [2:0]c;
	input [2:0]d;
	input [15:0]wrval;
	input wren;

	output [15:0]ret1;
	output [15:0]ret2;
	output [15:0]display;

	reg [15:0]regs[7:0];

	reg [15:0]ret1;
	reg [15:0]ret2;

	wire [15:0]display = regs[d];

	always @(posedge clk) begin
		if (wren) 
			regs[c] <= wrval;

		ret1 <= regs[a];
		ret2 <= regs[b];
	end
endmodule

module seg7(in,out);
    input [3:0]in;
    output [6:0]out;
    reg [6:0] out;

    always @(*) begin
        case (in)           // 6543210
            4'b0000 : out = 7'b1000000;
            4'b0001 : out = 7'b1111001;
            4'b0010 : out = 7'b0100100;
            4'b0011 : out = 7'b0110000;
            4'b0100 : out = 7'b0011001;
            4'b0101 : out = 7'b0010010;
            4'b0110 : out = 7'b0000010;
            4'b0111 : out = 7'b1111000;
            4'b1000 : out = 7'b0000000;
            4'b1001 : out = 7'b0011000;
            4'b1010 : out = 7'b0001000;
            4'b1011 : out = 7'b0000011;
            4'b1100 : out = 7'b0100111;
            4'b1101 : out = 7'b0100001;
            4'b1110 : out = 7'b0000110;
            4'b1111 : out = 7'b0001110;
            default:  out = 7'b1111111; 
        endcase
    end
endmodule